<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>什么东东的博客</title>
  
  <subtitle>认真工作、快乐生活</subtitle>
  <link href="/quandongli.github.io/atom.xml" rel="self"/>
  
  <link href="https://quandongli.github.io/"/>
  <updated>2020-01-31T11:36:33.847Z</updated>
  <id>https://quandongli.github.io/</id>
  
  <author>
    <name>CodeWhat</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面向对象三大特性之继承性</title>
    <link href="https://quandongli.github.io/post/3197e8b6.html"/>
    <id>https://quandongli.github.io/post/3197e8b6.html</id>
    <published>2020-01-31T11:21:58.000Z</published>
    <updated>2020-01-31T11:36:33.847Z</updated>
    
    <content type="html"><![CDATA[<p>这篇文章主要是对Java语言面向对象的三大特性中的继承性进行总结，主要包括：</p><ul><li>什么是继承性及其好处</li><li>继承性的实现与使用</li><li>方法的重写</li><li>super关键字<a id="more"></a><h2 id="什么是继承性？"><a href="#什么是继承性？" class="headerlink" title="什么是继承性？"></a>什么是继承性？</h2>所谓的继承性就是指一个类B可以继承另一个类A的所有属性和方法，并且在此基础上进行扩展或修改。继承性的存在可以带来以下几点好处：</li><li>减少代码的冗余，提高代码的复用性。子类可以直接继承父类的所有属性和方法，这样，子类中的一些方法就可以直接使用父类中的就可以了，而不需要自己在重新创建。</li><li>便于功能的扩展。子类如果需要扩展出某一个功能，可以直接调用父类中存在的一些必要的方法，也可以直接对父类的方法进行重写。</li><li>继承性为多态性提供了基础。没有继承性，那么多态性就无法实现。</li></ul><h2 id="继承性的实现"><a href="#继承性的实现" class="headerlink" title="继承性的实现"></a>继承性的实现</h2><p>Java中继承的实现使用以下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">B</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><blockquote><p>其中类A称为子类/派生类，B类称为父类/超类/基类。<br>Java.lang.Object类是一切类的父类。</p></blockquote><p>当子类A继承了父类B后，子类就能获得父类中的属性和方法</p><blockquote><p>父类私有的属性和方法，子类也依然继承，但是需要受封装性影响，子类不能直接调用父类的结构.</p></blockquote><p>子类在继承父类以后，还可以声明自己特有的属性或方法。</p><p>与此同时，类恶道继承也需要满足以下的规则：</p><ul><li>一个类可以被多个子类继承</li></ul><img src="/quandongli.github.io/post/3197e8b6/%E5%A4%9A%E5%B1%82%E7%BB%A7%E6%89%BF2.png" class title="多次继承"><ul><li>一个类只能由一个父类，称为单继承</li></ul><img src="/quandongli.github.io/post/3197e8b6/%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF.png" class title="多重继承"><ul><li>类可以被多层继承，子类直接继承的父类，称为直接父类，间接继承的父类称为间接父类。子类继承父类以后，就获取了直接父类以及所有间接父类中的属性和方法。</li></ul><img src="/quandongli.github.io/post/3197e8b6/%E5%A4%9A%E5%B1%82%E7%BB%A7%E6%89%BF.png" class title="多层继承"><h2 id="方法的重写"><a href="#方法的重写" class="headerlink" title="方法的重写"></a>方法的重写</h2><p>显然如果一个子类继承了父类的方法，父类的方法也不能百分百的满足子类的需求，这时候就需要对父类中相应的方法进行改造，这样，程序执行时，子类的方法将覆盖父类的方法。<br>子类重写方法的声明格式如下：</p><blockquote><p>权限修饰符 返回值类型 方法名(形参列表) throws 异常类型{ 方法体 }</p></blockquote><h3 id="方法重写的要求"><a href="#方法重写的要求" class="headerlink" title="方法重写的要求"></a>方法重写的要求</h3><p>方法的重写需要满足以下规定：</p><ul><li><p>1.子类重写的方法必须和父类被重写的方法具有相同的方法名称、参数列表</p></li><li><p>2.子类重写的方法的返回值类型不能大于父类被重写的方法的返回值类型</p><blockquote><ol><li>如果父类中被重写的方法的返回值类型是void，那么重写后的方法也需要时void</li><li>如果父类中被重写的方法的返回值类型是基本s数据类型(比如double)，那么子类重写的方法的返回值也必须是相同的类型</li><li>如果父类中被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类也可以是A类的子类。</li></ol></blockquote></li><li><p>3.子类重写的方法使用的访问权限不能小于父类被重写的方法的访问权限</p><blockquote><p>子类不能重写父类中声明为 private权限的方法</p></blockquote></li><li><p>4.子类方法抛出的异常不能大于父类被重写方法的异常</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：父类中由一个方法</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name,<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">那么子类重写的方法也必须是</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">(String name,<span class="keyword">int</span> num)</span><span class="comment">//其中形参变量名是可以改的</span></span></span><br></pre></td></tr></table></figure><h2 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h2><p>虽然我们可以在子类中对父类的方法、属性等进行重写，但是有时候我们又想在重写之后继续使用父类中的方法或属性，这是怎么办呢？</p><p>此时就需要使用关键字super，该关键字可以在属性、方法和构造器前使用，表明这里使用的是父类中的属性、方法或者构造器。<br>在调用父类中的属性和方法是，如果该方法没有在子类中重写，那么我们就可以省略super，编译器将自动调用父类中的方法，当子类重写了父类中的方法后，supper表明仍然使用父类中的方法。</p><ul><li>在调用构造器时，可以在子类中显式的使用super(形参列表)的方式，调用父类中声明指定的构造器，且“super(形参列表)”必须声明在子类列表的首行。</li><li>如果父类中没有无参构造器，并且在子列的构造器中有没有显式的调用父类的其他构造器，将会报错</li><li>其次在类的构造器中，this和supper调用同一构造器只能二选一，且子类中的构造器默认有一行super()以构建父类。</li><li>在类的多个构造器中，至少有一个类的构造器使用了super</li></ul><p>看下面一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明了一个animal类作为父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">animal</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;<span class="comment">//一个有参构造器，用于初始化age、name属性</span></span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;<span class="comment">//展示自己的属性</span></span><br><span class="line">System.out.println(<span class="string">"我的名字是："</span> + name);</span><br><span class="line">System.out.println(<span class="string">"我的年龄是："</span> + age);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建了animal的子类dog</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">dog</span> <span class="keyword">extends</span> <span class="title">animal</span> </span>&#123;</span><br><span class="line">String cry;<span class="comment">//增加了一个cry的属性，用于表示它的叫声</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">dog</span> <span class="params">(<span class="keyword">int</span> age,String name,String cry)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">super</span>(age,name);<span class="comment">//这里通过super对age和name属性进行初始化，也可以使用super.age =age进行初始化，不过这样，在animal类中需要有一个空参构造器</span></span><br><span class="line"><span class="keyword">this</span>.cry = cry;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;<span class="comment">//对display方法进行了从写</span></span><br><span class="line">System.out.println(<span class="string">"我的名字是："</span> + name);<span class="comment">//这里的name属性没有写super，是因为name属性在dog类中没有，编译器将在它的父类中寻找</span></span><br><span class="line">System.out.println(<span class="string">"我的年龄是："</span> + age);</span><br><span class="line">System.out.println(<span class="string">"我的叫声是："</span> + cry);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">dog Dog = <span class="keyword">new</span> dog(<span class="number">12</span>,<span class="string">"jone"</span>,<span class="string">"汪！汪！"</span>);<span class="comment">//这里的构造器必须使用dog类的构造器，而不能使用animal类中的构造器。因为这里实例化的是一个dog类</span></span><br><span class="line">Dog.display();</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">/*将会显示：</span></span><br><span class="line"><span class="comment">我的名字是：jone</span></span><br><span class="line"><span class="comment">我的年龄是：12</span></span><br><span class="line"><span class="comment">我的叫声是：汪！汪！</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><a href="https://mubu.com/doc/2I_YOgyeCw" target="_blank" rel="noopener">思维导图版笔记点此处</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这篇文章主要是对Java语言面向对象的三大特性中的继承性进行总结，主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是继承性及其好处&lt;/li&gt;
&lt;li&gt;继承性的实现与使用&lt;/li&gt;
&lt;li&gt;方法的重写&lt;/li&gt;
&lt;li&gt;super关键字&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://quandongli.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://quandongli.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>面向对象三大特性之封装性</title>
    <link href="https://quandongli.github.io/post/c08b9ed0.html"/>
    <id>https://quandongli.github.io/post/c08b9ed0.html</id>
    <published>2020-01-31T11:21:03.000Z</published>
    <updated>2020-01-31T11:27:10.821Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章将对Java面向对象三大特性中的封装性进行总结，主要包括以下几个方面：</p><ul><li>什么是封装性？</li><li>为什么要封装性？</li><li>怎么实现封装性？</li></ul><a id="more"></a><h2 id="什么是封装性"><a href="#什么是封装性" class="headerlink" title="什么是封装性"></a>什么是封装性</h2><p>在Java中所谓的封装性就是将一个类的某些方法进行“隐藏”，其他类不能够进行调用或直接的访问。比如：如果需要实现冒泡排序的一个类，那么我们就可以将交换元素的方法进行“隐藏”。<br>Java中的封装性就好比是电器上的一个个按钮，作为用户而言，只需要知道按什么按钮会有什么功能就可以了，不需要知道这个功能具体的实现细节。</p><h2 id="为什么要封装性"><a href="#为什么要封装性" class="headerlink" title="为什么要封装性"></a>为什么要封装性</h2><p>先看下面的代码：<br>这里先创建里一个animal类，里面有关于动物的姓名，年龄，有多少条手等属性，然后创建了一个display方法用于展示信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> leg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">animal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"my name is:"</span>+name);</span><br><span class="line">System.out.println(<span class="string">"my age is:"</span>+age);</span><br><span class="line">System.out.println(<span class="string">"I have "</span>+leg+<span class="string">" leg"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后创建一个dog对象，并赋值展示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">animal  dog = <span class="keyword">new</span> animal();</span><br><span class="line">dog.name = <span class="string">"jone"</span>;</span><br><span class="line">dog.age = -<span class="number">10</span>;</span><br><span class="line">dog.leg = -<span class="number">10</span>;</span><br><span class="line">dog.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>毫无意外的会展示：</p><blockquote><p>my name is:jone<br>my age is:-10<br>I have -10 leg</p></blockquote><p>但是这样的赋值合理吗？年龄是否可以是负数？-10条腿是多少？<br>显然这些情况都是不合理的！这时候就需要对这些输入进行一些判断和筛选，显然，如果将数据定义成谁都可以直接访问、赋值时不合理的。这是时就需要对这些属性进行封装，让使用者不能直接访问，而是需要通过调用相应的方法，我们就可以在这些方法里面对属性进行控制，使其保持合理的状态了。<br>对于一些方法也是这样，我们可以通过封装，而将部分实现细节进行隐藏。</p><h2 id="怎么实现封装"><a href="#怎么实现封装" class="headerlink" title="怎么实现封装"></a>怎么实现封装</h2><p>Java中的封装性是通过private关键字实现的，带有该关键字的<strong>属性、方法、构造器、内部类</strong>将只能在类内使用，在其他类中构造的对象将不能直接访问或调用。</p><blockquote><p>private不可以用于类<br>例如，将animal类中的age代码改成如下形式：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br></pre></td></tr></table></figure><p>直接调用将会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dog.age = <span class="number">10</span>;<span class="comment">//The field animal.age is not visible</span></span><br></pre></td></tr></table></figure><p>此时我们就可以通过构造相应的getter/setter方法对属性进行访问和设置：</p><blockquote><p>在eclipse中可以通过alt+ shift+s，批量自动构建属性的getter/setter方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">animal</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;        <span class="comment">//对属性进行了封装</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> leg;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"my name is:"</span>+name);</span><br><span class="line">System.out.println(<span class="string">"my age is:"</span>+age);</span><br><span class="line">System.out.println(<span class="string">"I have "</span>+leg+<span class="string">" leg"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;<span class="comment">//获取age属性</span></span><br><span class="line"><span class="keyword">return</span> age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;<span class="comment">//设置age属性(大于等于0并且小于等于100)</span></span><br><span class="line"><span class="keyword">if</span>(age &gt;= <span class="number">0</span> &amp;&amp; age&lt;= <span class="number">100</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;<span class="comment">//设置name属性，长度小于7</span></span><br><span class="line"><span class="keyword">if</span>(name.length()&lt;= <span class="number">7</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getLeg</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> leg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLeg</span><span class="params">(<span class="keyword">int</span> leg)</span> </span>&#123;<span class="comment">//设置leg属性(大于等于0并且小于等于100)</span></span><br><span class="line"><span class="keyword">if</span>(leg &gt;= <span class="number">0</span> &amp;&amp; leg&lt;= <span class="number">100</span>) &#123;</span><br><span class="line"><span class="keyword">this</span>.leg = leg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时如果进行如下调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">animal  dog = <span class="keyword">new</span> animal();</span><br><span class="line">dog.setAge(-<span class="number">10</span>);</span><br><span class="line">dog.setLeg(-<span class="number">10</span>);</span><br><span class="line">dog.setName(<span class="string">"jahfeisnshiwon"</span>);</span><br><span class="line">dog.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，属性赋值将不会成功，属性将会是默认值：</p><blockquote><p>my name is:null<br>my age is:0<br>I have 0 leg</p></blockquote><p>通过将属性进行封装，就可以对属性进行控制，防止属性被随意设置，并且也可以在程序中明确的知道在哪里怎么设置了那个属性，使程序的可读性更强。</p><p><a href="https://mubu.com/doc/2I_YOgyeCw" target="_blank" rel="noopener">幕布版思维导图</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章将对Java面向对象三大特性中的封装性进行总结，主要包括以下几个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;什么是封装性？&lt;/li&gt;
&lt;li&gt;为什么要封装性？&lt;/li&gt;
&lt;li&gt;怎么实现封装性？&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://quandongli.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://quandongli.github.io/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>eclipse常用快捷键</title>
    <link href="https://quandongli.github.io/post/ca1e56df.html"/>
    <id>https://quandongli.github.io/post/ca1e56df.html</id>
    <published>2020-01-28T07:09:36.000Z</published>
    <updated>2020-01-28T07:15:45.842Z</updated>
    
    <content type="html"><![CDATA[<p>eclipse的常用快捷键</p><a id="more"></a><h2 id="快速导入-快速修复-快速生成相关代码"><a href="#快速导入-快速修复-快速生成相关代码" class="headerlink" title="快速导入/快速修复/快速生成相关代码"></a>快速导入/快速修复/快速生成相关代码</h2><p>1.补全代码的声明：alt+/<br>2.快速修复：ctrl+l<br>3.批量导包：ctrl+shift+o<br>4.调出生成 getter/ setter/构造器等结构：alt+ shift+s</p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>5.使用单行注释：ctrl+/<br>6.使用多行注释：ctrl+ shift+/<br>2.快速修复：ctrl+l<br>3.批量导包：ctrl+ shift+o<br>4.使用单行注释：ctrl+/<br>5.使用多行注释：ctrl+ shift+<br>7.取消多行注释：ctrl+ shift+</p><h2 id="移动代码"><a href="#移动代码" class="headerlink" title="移动代码"></a>移动代码</h2><p>8.复制指定行的代码：ctrl+alt+down或ctrl+alt+up<br>9.删除指定行的代码：ctrl+d<br>10.上下移动代码：alt+up或alt+down<br>11.切换到下一行代码空位：shft+ enter<br>12.切换到上一行代码空位：ctr1l+ shift+ enter</p><h2 id="查看代码"><a href="#查看代码" class="headerlink" title="查看代码"></a>查看代码</h2><p>13.如何查看源码：ctrl+选中指定的结构或ctrl+ shift+t<br>14在当前生中，显示结构，并支持世索指定的方法属性等，ctrl+o<br>15.光标选中指定的类，查看继承树结构：ctrl+t<br>16.显示当前选择资源（工程or文件）的属性：alt+ enter<br>17.快速查找：参照选中的ord快速定位到下一个：ctrl+k</p><h2 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h2><p>18.批量修改指定的变量名、方法名、类名等：alt+ shift+<br>19.选中的结构的大小写的切换：变成大写：ctrl+ shift+x<br>20.选中的结构的大小写的切换：变成小写：ctrl+shift+y<br>21.格式化代码：ctrl+shft+f<br>22.选中数行，整体往后移动：tab<br>23.选中数行，整体往前移动：shiftt+tab</p><h2 id="页面编辑"><a href="#页面编辑" class="headerlink" title="页面编辑"></a>页面编辑</h2><p>24.退回到前一个编辑的页面：alt+left<br>25.进入到下一个编辑的页面（针对于上面那条来说的）：alt+ right</p><h2 id="普通复制粘贴"><a href="#普通复制粘贴" class="headerlink" title="普通复制粘贴"></a>普通复制粘贴</h2><p>26.复制代码：ctrl+c<br>27.撤销：ctrl+z<br>28.反撤销：ctrl+y<br>29.剪切：ctrl+x<br>30.剪切：ctrl+v<br>31.粘贴：ctrl+V<br>32.全选：ctrl+a</p><h2 id="不常用的快捷键"><a href="#不常用的快捷键" class="headerlink" title="不常用的快捷键"></a>不常用的快捷键</h2><p>33.关闭当前窗口：ctrl+W<br>34.关闭所有的窗口：ctrl+ shift+W<br>35.查看指定的结构使用过的地方：ctrl+alt+g<br>36.查找与替换：ctrl+f<br>37.最大化当前的VieW：ctrl+m<br>38.直接定位到当前行的首位：home<br>39.直接定位到当前行的末位：end</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;eclipse的常用快捷键&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://quandongli.github.io/categories/java/"/>
    
    
      <category term="eclipse" scheme="https://quandongli.github.io/tags/eclipse/"/>
    
  </entry>
  
  <entry>
    <title>面向对象之类的使用</title>
    <link href="https://quandongli.github.io/post/cfec4ed.html"/>
    <id>https://quandongli.github.io/post/cfec4ed.html</id>
    <published>2020-01-21T13:37:10.000Z</published>
    <updated>2020-01-21T13:40:49.084Z</updated>
    
    <content type="html"><![CDATA[<p>本文将通过介绍使用类的步骤对类的相关知识进行总结。</p><blockquote><p>文中提出的步骤并不一定是实际操作中的顺序或者必要的步骤，只是为了更好的总结而为之</p></blockquote><a id="more"></a><h2 id="使用预定义类"><a href="#使用预定义类" class="headerlink" title="使用预定义类"></a>使用预定义类</h2><p>所谓预定义类即为Java设计者们向使用者提供的已经设计好的类。可以通过官方API文档进行查看。<br>使用预定义类主要分为以下几个步骤：</p><h3 id="第一步：导入包"><a href="#第一步：导入包" class="headerlink" title="第一步：导入包"></a>第一步：导入包</h3><p>java中一个类一定是在某一个中。如果需要使用某一个类，必须向编译器说明导入该类所在的包及其位置。</p><p>导入一个包有以下三种方式：<br><strong>第一种：完全限定名</strong><br>这种方式是在使用某一个类时，将包名和类名完整的写下来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.time.LocalDate today = java.time.LocalDate.now;<span class="comment">// 这里实例化了一个LocalDate类</span></span><br></pre></td></tr></table></figure><p>这种方式的缺点是以后每次需要实例化一个类时，都需要这样写。会很麻烦。<br><strong>第二种：使用import</strong><br>使用import导入包或者类之后将不需要完整的写下包名。</p><ul><li>导入一个包中所有的类：import &lt; package name &gt;.*</li></ul><blockquote><p>如：import java.time.*;// 导入了java.time包中所有的类</p></blockquote><ul><li>导入一个特定的类：import &lt; package name &gt;.classname</li></ul><blockquote><p>如：import java.time.LocalDate;// 导入了java.time包中所有的类</p></blockquote><p>在java不同的包可能有相同的类名，在使用这些类时需要告诉编译器你正在使用那个类。<br>例如：java.util包和java.sql包中都有Date类。如在程序中同时导入了这两个包，在使用Date类时将会报错。<br>这是后可以加上一句：</p><blockquote><p>import java.util.Date;​</p></blockquote><p>这将告诉编译器，在本程序中使用的Date类都是java.util包中的Date类。<br>或者在使用Date类时再告诉编译器，究竟使用的是那个包中的Date类。</p><blockquote><p>var today = new java.util.Date()//这将告诉编译器，这个today对象使用的是java.util包中的Date类。</p></blockquote><p><strong>第三种静态导入</strong><br>再import后面加入static类将会告诉浏览器只导入指定包中的所有类的静态方法和静态字段（前提是存在静态方法和静态字段，如果没有则会报错）<br>例如在程序中导入：</p><blockquote><p>import static java.lang.System.*;</p></blockquote><p>则在程序中可以直接使用 out.println()方法打印东西。</p><h3 id="第二步-使用构造器实例化一个对象"><a href="#第二步-使用构造器实例化一个对象" class="headerlink" title="第二步 使用构造器实例化一个对象"></a>第二步 使用构造器实例化一个对象</h3><p>在Java中任何类的使用都要使用构造器构造一个对象，然后才能通过这个对象使用类中的方法。<br>语法为：new 类名</p><p>关于构造器将会在后面进行详细介绍。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>实例化一个对象之后就可以通过这个对象来调用类中的方法了。</p><ul><li>直接将对象传递给一个方法</li></ul><blockquote><p>System.out.println(new Date())//将会输出当前时间</p></blockquote><ul><li>直接对对象运用方法</li></ul><blockquote><p>String Today = new Date().toString();//将当前日期转换为字符串传递给Today变量</p></blockquote><p>这两种方法构造出的对象将会只能使用一次，如果下次需要使用则需要继续构造。</p><ul><li>将对象传递给一个对象对象变量</li></ul><blockquote><p>Date Today = new Date()//将对象传递给了Today变量，并且 该对象可以使用任意次​​.</p></blockquote><h2 id="使用用户自定义类"><a href="#使用用户自定义类" class="headerlink" title="使用用户自定义类"></a>使用用户自定义类</h2><p>虽然Java的设计者给我们提供了种类繁多的格式个样的类,但是也一定无法完全满足,我们日常开发中对类的需求.所以,在项目的实施过程中,也需要自己定义出需要的类.</p><h3 id="第一步-创建一个类"><a href="#第一步-创建一个类" class="headerlink" title="第一步:创建一个类"></a>第一步:创建一个类</h3><p>这一步通常是只用IDE软件完成,在创建类的时候子需要选择类需要在的包,并且给类设定一个名字(命名规则同变量),即可.通常类的名字与类的文件名是一样的.并且在类的最开始出将会自动给出用于告诉编译器类的位置的语句,如:</p><blockquote><p>package cons;</p></blockquote><p>并且会将类自动的设定为public.</p><h3 id="第二步-创建构造器"><a href="#第二步-创建构造器" class="headerlink" title="第二步 创建构造器"></a>第二步 创建构造器</h3><p>所谓的构造器主要是用于将类设定为指定的初始状态在创建构造器是需要注意以下几点:<br><strong>第一：</strong> 构造器需要与类的名字一样.<br><strong>第二：</strong> 每一个类可以有一个或以上的构造器.如果没有自定义构造器，编译器将会自动提供一个无参构造器，并将实例字段初始化为默认设置(比如将double类型的实例字段初始化为0.0等).当该类拥有参数构造器，但是没有设定无参构造器时，将不会提供无参构造器。构造器将会通过参数情况选择正确的构造器,如果构造对象时没有提供正确的参数，将会报错.</p><p>现在创建一个text类(在同一个包中)，并在类中写入以下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">String s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在程序中使用这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">text t = <span class="keyword">new</span> text();</span><br><span class="line">System.out.println(t.s);<span class="comment">//将会输出null</span></span><br></pre></td></tr></table></figure><p>现在再将text类改写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">String s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">text</span><span class="params">()</span> </span>&#123;<span class="comment">//无参构造器</span></span><br><span class="line">s = <span class="string">"我没有参数"</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">text</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;<span class="comment">//接收一个int类型的数值</span></span><br><span class="line">s = <span class="string">"我有参数"</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再使用这个类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text t1 = <span class="keyword">new</span> text();</span><br><span class="line">System.out.println(t1.s);<span class="comment">//输出：我没有参数</span></span><br><span class="line">text t2 = <span class="keyword">new</span> text(<span class="number">3</span>);<span class="comment">//输出：我有参数</span></span><br><span class="line">System.out.println(t2.s);</span><br></pre></td></tr></table></figure><p><strong>第三：</strong> 构造器没有返回值。<br>如果在上面的构造器中加入</p><blockquote><p>return 0;</p></blockquote><p>将会报错：</p><blockquote><p>Void methods cannot return a value</p></blockquote><p><strong>第四：</strong> 构造器总是伴随着操作符new一起被调用。</p><p>构造器的调用顺序为：<br>1.如果构造器的第一行调用了另一个构造器，则基于所提供的参数执行第二个构造器。<br>2.否则，将所有数据字段初始化为默认值，并按照在类的声明中出现的顺序，执行所有字段初始化方法或初始化块。<br>3.执行构造器的主体代码</p><p>现在将text类中的内容改写为以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> String s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">text</span><span class="params">()</span> </span>&#123;</span><br><span class="line">s = <span class="string">"我没有参数"</span>;</span><br><span class="line">text t3 = <span class="keyword">new</span> text(<span class="number">3</span>);<span class="comment">//在无参构造器中调用了下面的构造器</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">text</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">s = <span class="string">"我有参数"</span>;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在使用该类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">text t1 = <span class="keyword">new</span> text();</span><br><span class="line">System.out.println(t1.s);<span class="comment">//将会输出：我有参数，说明第二个构造器被执行</span></span><br><span class="line">text t2 = <span class="keyword">new</span> text(<span class="number">3</span>);</span><br><span class="line">System.out.println(t2.s);<span class="comment">//输出：我有参数</span></span><br></pre></td></tr></table></figure><h3 id="第三步-创建实例字段"><a href="#第三步-创建实例字段" class="headerlink" title="第三步:创建实例字段"></a>第三步:创建实例字段</h3><p>实例字段主要是用来表示对象初始化状态的一类变量，这些变量将会在构造器中被初始化为指定的状态（或默认状态）。例如，上例text类中的：</p><blockquote><p>String s;</p></blockquote><p>就是一个实例字段。</p><h4 id="设置访问权限"><a href="#设置访问权限" class="headerlink" title="设置访问权限"></a>设置访问权限</h4><p>首先，我们需要给我们的实例字段设定访问权限(即谁可以访问我)。</p><ul><li>默认情况。默认情况下是只要是同一个包内的另一个类可以使用。上例中使用了text类中的s实例对象就没有报错。</li></ul><p>现在我们建立另外一个包，并在里面创建一个friend类。在里面写入以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> text;<span class="comment">//包名</span></span><br><span class="line"><span class="keyword">import</span> cons.text;<span class="comment">//引入text类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">friend</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">text</span><span class="params">()</span> </span>&#123;</span><br><span class="line">String b;</span><br><span class="line">text t = <span class="keyword">new</span> text();<span class="comment">//使用text类</span></span><br><span class="line">b = t.s;<span class="comment">//会报错，因为在text类中的s没有声明为public。</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>public。有public关键词的实例对象将允许任何类访问(即使不在同一个包中)。上例中如果将text类中的s前面加上public将不会报错。</li><li>private。有private关键字的实例对象将不允许其他的类访问这个实例对象，这个实例对象仅能在自己所在的类中被调用。<br>在Java中。一般我们会将类中的实例字段声明为private，并在类中创建一个字段更改其(setter+字段名)和字段访问器（getter+字段名）。这样做更加符合类的封装性，我们恶意很清楚的知道在什么时候对那个类中的字段进行了修改。于是我们因该将text类中的改为如下内容：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setters</span><span class="params">(String s)</span> </span>&#123;<span class="comment">//修改器</span></span><br><span class="line"><span class="keyword">this</span>.s=s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getters</span><span class="params">()</span> </span>&#123;<span class="comment">//访问器</span></span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>现在再来使用text类：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">text t1 = <span class="keyword">new</span> text();</span><br><span class="line">t1.setters(<span class="string">"我改了"</span>);</span><br><span class="line">System.out.println(t1.getters());<span class="comment">//将会打印：我改了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="设置读写权限"><a href="#设置读写权限" class="headerlink" title="设置读写权限"></a>设置读写权限</h4>设置完字段的访问权限之后，我们需要再来设置字段的读写权限。<ul><li>默认情况：再不加任何相关关键字的情况下字段将可读可写。</li><li>final:将字段设置为常量，这将使得改字段再任何情况下都能更改。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String s;<span class="comment">//设置为常量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.s=s;<span class="comment">//将会报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getters</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>static：所有使用这个类创建的对象将会共享这个字段，即一个对象对这个字段进行了更改，另一个对象中也会更改。</li></ul><p>将text类改为以下内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String s;<span class="comment">//设置为静态</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setters</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.s=s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getters</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在再来使用这个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">text t1 = <span class="keyword">new</span> text();</span><br><span class="line">text t2 = <span class="keyword">new</span> text();</span><br><span class="line">t1.setters(<span class="string">"我要改t2"</span>);</span><br><span class="line">System.out.println(t2.getters());<span class="comment">//将会打印：我要改t2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化字段"><a href="#初始化字段" class="headerlink" title="初始化字段"></a>初始化字段</h4><p>设置完实例字段的相关权限之后，接下来我们就要来考虑一下它们的初始状态，我们可以再以下几个地方进行初始化：</p><ul><li>构造器</li><li>声明时</li><li>初始化块中</li></ul><p>将text类改为以下内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line"> String s1 = <span class="string">"我是声明"</span>;</span><br><span class="line"> String s2;</span><br><span class="line"> String s3;</span><br><span class="line"> &#123;</span><br><span class="line"> s2 = <span class="string">"我是初始化块"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">text</span><span class="params">()</span> </span>&#123;</span><br><span class="line">s3 = <span class="string">"我是构造器"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">text t2 = <span class="keyword">new</span> text();</span><br><span class="line">System.out.println(t2.s1);<span class="comment">//我是声明</span></span><br><span class="line">System.out.println(t2.s2);<span class="comment">//我是初始化块</span></span><br><span class="line">System.out.println(t2.s3);<span class="comment">//我是构造器</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>设置完字段之后，接下来就因该给这个类设置一些方法了。</p><h4 id="设置方法的访问权限"><a href="#设置方法的访问权限" class="headerlink" title="设置方法的访问权限"></a>设置方法的访问权限</h4><p>需要设置的访问权限有两种（是自己用？还是大家用）</p><ul><li>默认情况：跟字段一样，默认情况是再同一个包中的可以使用。</li><li>public：大家都可以用。</li><li>private：只有自己可以使用</li></ul><p>我们给text中加入两个方法来实现冒泡排序，其中一个方法用来比较大小(设为public)，另外一个方法用来交换（设为private）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span>[] info,<span class="keyword">int</span> num)</span> </span>&#123;<span class="comment">//求数组中最大的数</span></span><br><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; num;i++)</span><br><span class="line">&#123;</span><br><span class="line">max = isMax(max,info[i]);<span class="comment">//调用isMax方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">isMax</span><span class="params">(<span class="keyword">int</span> max,<span class="keyword">int</span> num)</span><span class="comment">//返回两个数中较大的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(max &lt; num)</span><br><span class="line">max = num;</span><br><span class="line"><span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用这个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">text whoismax = <span class="keyword">new</span> text();</span><br><span class="line"><span class="keyword">int</span>[] num = &#123;<span class="number">23</span>,<span class="number">134</span>,<span class="number">933</span>,<span class="number">34</span>,<span class="number">930</span>, <span class="number">45</span>&#125;;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"the max numble is:"</span>+whoismax.max(num,num.length));<span class="comment">//将会返回933</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>如果直接调用isMax方法将会报错。</p></blockquote><h4 id="设置静态方法"><a href="#设置静态方法" class="headerlink" title="设置静态方法"></a>设置静态方法</h4><p>在之前使用预定义中提到可以导入类中的静态方法，现在将对静态方法进行一个简单介绍。<br>在使用静态方法是需要注意以下几点：</p><ul><li>非静态方法既可以访问静态数据成员 又可以访问非静态数据成员，而静态方法只能访问静态数据成员；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">String s;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">text</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s;<span class="comment">//将会报错，因为s不是静态数据</span></span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>非静态方法既可以访问静态方法又可以访问非静态方法，而静态方法只能访问静态数据方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line">String s;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">text1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">text2();<span class="comment">//将会报错，因为text2不是静态方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span>  String <span class="title">text2</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当有某一个类构造了多个对象，则这几个对象将操作同一个静态方法（即静态方法共享内存）</li></ul><p>我们在text类总设置一个静态方法，返回静态字符串s当前的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> String s;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">name</span><span class="params">(String name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">s = name;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>并调用它：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">text name1 = <span class="keyword">new</span> text();</span><br><span class="line">text name2 = <span class="keyword">new</span> text();</span><br><span class="line">System.out.println(<span class="string">"name1中s为："</span>+name1.name(<span class="string">"first"</span>));<span class="comment">//将会输出first</span></span><br><span class="line">System.out.println(<span class="string">"name2中s为："</span>+name2.s);<span class="comment">//虽然name2对象中的s值没有设置，但是它与那么共享，将会输出first</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"name2中s为："</span>+name2.name(<span class="string">"next"</span>));<span class="comment">//将会输出next</span></span><br><span class="line">System.out.println(<span class="string">"name1中s为："</span>+name1.s);<span class="comment">//由于s的值已经通过name2修改，所以name1中的s值为：next</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其在内存中的示意图，可以简略的用以下方式表示：</p><img src="/quandongli.github.io/post/cfec4ed/%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E5%86%85%E5%AD%98.png" class title="静态方法内存示意图"><ul><li>静态方法可以不使用对象，而直接调用。也就是没有隐式参数<br>如：Math.pow()</li></ul><h4 id="设置方法名"><a href="#设置方法名" class="headerlink" title="设置方法名"></a>设置方法名</h4><p>方法名是用来告诉编译器我们正要使用该类中的哪一个方法。其命名又以下规则:</p><ul><li>命名规则同变量的命名规则</li><li>最好使用小驼峰命名法，并且方法名能够说明该方法可以做什么</li></ul><p>此外在java中还有方法的重载形式，它允许存在多有方法名相同，但是参数不同(个数、类型、顺序等)的方法，这使得我们可以为一些需要考虑输入数据的类型进行不同处理以达到相同作用的方法设置相同的方法名。例如：println方法就可以根据用户传入的数据类型选择合适的方法以显示。</p><h4 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h4><p>在方法中有时候需要用户传入一些数据，有时候需要使用已经定义的实例变量，需要根据实际需要进行选择。这些参数可以被分为两种类型：</p><ul><li>显式参数：就是在方法名义中的小括号中写明的，明确的告诉用户需要传入什么类型的数据。如，上例中，text类的name方法的字符串name就是一个显式参数。</li><li>隐式参数：在方法的声明中并没有明确的写出来，但是在实际操作中需要使用到类中的其他变量，例如name方法就使用了静态变量s。这是s就是一个隐式参数。</li></ul><p>但是如果我将text类中name方法改成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">name</span><span class="params">(String name)</span><span class="comment">//返回两个数中较大的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">name = name;</span><br><span class="line"><span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是的隐式参数和显示参数名字都是name，现在再调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">text name1 = <span class="keyword">new</span> text();</span><br><span class="line">text name2 = <span class="keyword">new</span> text();</span><br><span class="line">System.out.println(<span class="string">"num1中s为："</span>+name1.name(<span class="string">"first"</span>));<span class="comment">//first</span></span><br><span class="line">System.out.println(<span class="string">"num2中s为："</span>+name2.name);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"num2中s为："</span>+name2.name(<span class="string">"next"</span>));<span class="comment">//next</span></span><br><span class="line">System.out.println(<span class="string">"num1中s为："</span>+name1.name);<span class="comment">//null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是为什么呢？<br>因为在默认情况下，方法将会使用显示参数，也就是说在上例中，方法使用的都是传入的name值，并没有使用静态字符串name。这种情况下需要使用this关键字告诉编译器，哪里使用的是隐式参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">text</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> String name;</span><br><span class="line"><span class="function"><span class="keyword">public</span>  String <span class="title">name</span><span class="params">(String name)</span><span class="comment">//返回两个数中较大的数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.name = name;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样输出的内容与上面的一样。</p><blockquote><p>前面说过在静态方法中没有this关键字，会报错，所以这里不能将方法仍设置为静态</p></blockquote><h4 id="设置方法的变量名"><a href="#设置方法的变量名" class="headerlink" title="设置方法的变量名"></a>设置方法的变量名</h4><p>我们需要为方法设置一些需要使用到的变量，这些变量将只会在改方法中有效。</p><ul><li>可以定义基本类型变量、定义引用变量或者对象变量</li><li>变量名需要符合变量命名规则</li><li>如果可以从对象的初始值退推测出变量的类型，则可以使用var关键字<blockquote><p>var Today = new Date()</p></blockquote></li></ul><p><strong>var只能用于方法中局部变量的命名</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将通过介绍使用类的步骤对类的相关知识进行总结。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;文中提出的步骤并不一定是实际操作中的顺序或者必要的步骤，只是为了更好的总结而为之&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://quandongli.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://quandongli.github.io/tags/java/"/>
    
      <category term="面向对象" scheme="https://quandongli.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
      <category term="类" scheme="https://quandongli.github.io/tags/%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>离散数学之第一节习题</title>
    <link href="https://quandongli.github.io/post/3f639265.html"/>
    <id>https://quandongli.github.io/post/3f639265.html</id>
    <published>2020-01-18T05:26:24.000Z</published>
    <updated>2020-01-21T13:38:44.664Z</updated>
    
    <content type="html"><![CDATA[<p>题目出处：《离散数学及其应用》p11页53题<br>题干：</p><blockquote><p>有一个含有100条语句的列表，其中第n条语句写的是“列表中恰好有n条语句为假”<br>a) 你能从这些语句中得出什么结论、<br>b) 如果第n条语句写的是“列表中至少有n条语句为假”，回答问题a<br>c) 假设这个列表包含99条语句，回答问题b</p></blockquote><a id="more"></a><h2 id="理解题意"><a href="#理解题意" class="headerlink" title="理解题意"></a>理解题意</h2><p>该题的题意如果用表格的形式进行展现，应该是如下的表格：</p><table><thead><tr><th align="center">题号</th><th align="center">内容</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">列表中恰好(至少)有1条语句为假</td></tr><tr><td align="center">2</td><td align="center">列表中恰好(至少)有2条语句为假</td></tr><tr><td align="center">3</td><td align="center">列表中恰好(至少)有3条语句为假</td></tr><tr><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">100</td><td align="center">列表中恰好(至少)有100条语句为假</td></tr></tbody></table><h2 id="解a题"><a href="#解a题" class="headerlink" title="解a题"></a>解a题</h2><p>首先假设第一条语句是真的情况，则在后面的语句中至少有一条语句是假的。现在假设第二条语句为假，则其他语句都是真的。但是第三条语句：列表中恰好有3条语句是假的。与第一条语句：表中恰好有1条语句是假的。发生了冲突。所以第一语句不可能是真的，换句话说第一条语句一定为假。</p><blockquote><p>从这个过程中，我们可以发现，这个问题的结论一定是只有某一条语句为真，其他语句都为假</p></blockquote><p>再来分析第二条语句：列表中恰好有2条语句是假的。假设这句话是真的，通过上面的分析知道，第一条语句一定是假的，所以另外一条为假的语句一定再第二条语句的后面，而且有且只有一条。同样假设第三条语句是真的。则于第二条语句发生了冲突，所以第二条语句也一定是假的。<br>通过再次的分析，我们可以发现，如果第n条语句是真的，则其前面的n-1条语句一定都是假的。其后面的语句中有且只有一条语句是假的。同时还需要保证第n条语句后面没有真语句。也就是说，这个为真的第n条语句后面只能由一条语句且这条语句为假。那么这个n也就只有了一个取值— 99.<br>所以问题的答案就是：<strong>只有第99条语句是真的，其他语句都是假的。</strong> </p><blockquote><p>这里也可以继续往下推演，一次假设第三条、第四条….语句是真的。也能够得到同样的答案。</p></blockquote><h2 id="解b题"><a href="#解b题" class="headerlink" title="解b题"></a>解b题</h2><p>对于这个问题，我们需要从后往前检验。<br>先检验第100条语句。假设第100语句是真的(也就是说：列表中至少有100语句是假的，这句话是真的)。但是列表中还剩下99条语句，也就是说列表中最多也就99条语句是假的，与假设矛盾了。所以第100语句一定是假的。<br>再检验的99条语句。假设第99条语句：列表中至少有99语句是假的。假设这句话是真的，则其他列表中其他的语句都是假的。对于第98条语句：列表中至少有98语句是假的。如果这句话是假的，那么这句话的否定：列表中假的语句小于98条，这句话是真的。但是这句第99条语句矛盾。所以第99条语句也是假的。</p><blockquote><p>从这段分析中可以发现，如果第n条语句是真的，那么n+1 ~ 100条语句都是假的，且1 ~ n条语句都是真的</p></blockquote><p>再检验第98条语句。同样假设这句话是真的。则前面的1~97条语句都应该是真的才对，这与假设矛盾。所以这句话是错的。<br>可以用同样的方法检测之后的语句。</p><p>现在检测第50条语句。假设这条语句是真的。通过上面的检测，可以知道51 ~ 100条语句，都是假的，也就是说现在已经有50条语句是假的了。无论第50条语句前有多少条语句是假的(这也不可能，因为后面已经都50条语句是假的了，则1 ~ 50条语句一定是真的)，第50条语句一定是真的。</p><p>所以本题答案为：<strong>1 ~ 50条语句都为真，51 ~ 100条语句都为假。</strong></p><h2 id="解C题"><a href="#解C题" class="headerlink" title="解C题"></a>解C题</h2><p>上体的结论同样适用于本题——<strong>如果第n条语句是真的，那么n+1~99条语句都是假的，且1 ~ n条语句都是真的</strong><br>直接来看第50条语句：列表中至少有50条语句是假的。假设这句话是真的，则说明其后面的49条语句都是假的，前面有还需要有一条语句是假的。假设这条语句是第49条语句。但是再49条语句后面至少有49条语句是假的，则这个命题又一定是真的。所以第50条语句为假。但是一旦第五十条语句也为真，那么列表中就有50条语句是假的了，这样第50条语句就是真的了。所以50条语句就真也不对，假也不对。这样这个命题就是一个悖论。不是一个命题。<br>所以本题答案为：<strong>这不是一个命题。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目出处：《离散数学及其应用》p11页53题&lt;br&gt;题干：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;有一个含有100条语句的列表，其中第n条语句写的是“列表中恰好有n条语句为假”&lt;br&gt;a) 你能从这些语句中得出什么结论、&lt;br&gt;b) 如果第n条语句写的是“列表中至少有n条语句为假”，回答问题a&lt;br&gt;c) 假设这个列表包含99条语句，回答问题b&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="离散数学" scheme="https://quandongli.github.io/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="离散数学" scheme="https://quandongli.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
      <category term="命题的逻辑" scheme="https://quandongli.github.io/tags/%E5%91%BD%E9%A2%98%E7%9A%84%E9%80%BB%E8%BE%91/"/>
    
      <category term="离散数学练习" scheme="https://quandongli.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6%E7%BB%83%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>离散数学之命题的逻辑</title>
    <link href="https://quandongli.github.io/post/cddb6940.html"/>
    <id>https://quandongli.github.io/post/cddb6940.html</id>
    <published>2020-01-17T05:21:12.000Z</published>
    <updated>2020-01-17T05:30:18.624Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章主要总结了来自《离散数学及其应用》的第一章第一小结的内容。主要包括：</p><ul><li>命题的一些基本概念</li><li>逻辑运算符及其运算规则</li><li>比特运算<a id="more"></a><h2 id="命题的概念"><a href="#命题的概念" class="headerlink" title="命题的概念"></a>命题的概念</h2>命题就是就是一个陈述句，它或真（通常用T表示）或假（通常用F表示），但是不能又真又假。<blockquote><p>例如：北京是中国的首都。是一个真命题<br>北京是中国的首都吗？就不是一个命题</p></blockquote></li></ul><p>当一个命题不能被再次分解为其他命题的组合时，则称这个命题为一个<strong>原子命题</strong>，如上例即为一个原子命题，由两个或以上的命题通过逻辑运算符组合而成的命题，称为<strong>复合命题</strong>。</p><blockquote><p>北京时中国的首都，并且华盛顿时美国的首都。就不是一个原子命题。</p></blockquote><p>一个原子命题通常用一个字母来表示。例如我们可以使用p来表示北京是中国的首都这个命题。</p><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><p>逻辑运算符主要用来表示命题与命题直接的关系。</p><ul><li>否定运算符：表示与命题p相反恶的情况，记作：┑p<blockquote><p>如上例的否定为：北京不是中国的否定</p></blockquote></li></ul><p>其真值表为：</p><table><thead><tr><th align="center">p</th><th align="center">┑p</th></tr></thead><tbody><tr><td align="center">T</td><td align="center">F</td></tr><tr><td align="center">F</td><td align="center">T</td></tr></tbody></table><ul><li>合取：表示两个命题都为真才为真的情况。记作p∧q。<blockquote><p>在计算机中通常用与（&amp;）表示。符号可以看作时A没有中间一横。记作And</p></blockquote></li></ul><blockquote><p>例如：北京是中国的首都，并且华盛顿是美国的首都。这是一个真命题</p></blockquote><p>其真值表为：</p><table><thead><tr><th align="center">p</th><th align="center">q</th><th align="center">p∧q</th></tr></thead><tbody><tr><td align="center">T</td><td align="center">T</td><td align="center">T</td></tr><tr><td align="center">T</td><td align="center">F</td><td align="center">F</td></tr><tr><td align="center">F</td><td align="center">T</td><td align="center">F</td></tr><tr><td align="center">F</td><td align="center">F</td><td align="center">F</td></tr></tbody></table><ul><li>析取:表示两个命题中至少有一个为真的情况。记作p∨q<blockquote><p>在计算机中用或（|）表示,</p></blockquote></li></ul><blockquote><p>例如：北京是中国的首都，或者巴黎是美国的首都。这是一个真命题</p></blockquote><p>其真值表为：</p><table><thead><tr><th align="center">p</th><th align="center">q</th><th align="center">p∨q</th></tr></thead><tbody><tr><td align="center">T</td><td align="center">T</td><td align="center">T</td></tr><tr><td align="center">T</td><td align="center">F</td><td align="center">T</td></tr><tr><td align="center">F</td><td align="center">T</td><td align="center">T</td></tr><tr><td align="center">F</td><td align="center">F</td><td align="center">F</td></tr></tbody></table><ul><li>异或：表示两个命题的真值不同才为真的情况，记作：记作p⊕q</li></ul><blockquote><p>例如：我可以吃一碗面或者一碗饭。</p></blockquote><p>其真值表为：</p><table><thead><tr><th align="center">p</th><th align="center">q</th><th align="center">p⊕q</th></tr></thead><tbody><tr><td align="center">T</td><td align="center">T</td><td align="center">F</td></tr><tr><td align="center">T</td><td align="center">F</td><td align="center">T</td></tr><tr><td align="center">F</td><td align="center">T</td><td align="center">T</td></tr><tr><td align="center">F</td><td align="center">F</td><td align="center">F</td></tr></tbody></table><ul><li>条件语句：表示p为真则q必为真。记作p→q。表示如果p，则q.p称为前提，q称为结论</li></ul><p>在现实的应用中，条件语句常有如下变换表达形式：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 如果p，则q</span><br><span class="line"><span class="number">2.</span> p蕴含q</span><br><span class="line"><span class="number">3.</span> p仅q</span><br><span class="line"><span class="number">4.</span> p是q的充分条件</span><br><span class="line"><span class="number">5.</span> q是p的必要条件</span><br></pre></td></tr></table></figure><p>其真值表为：</p><table><thead><tr><th align="center">p</th><th align="center">q</th><th align="center">p→q</th></tr></thead><tbody><tr><td align="center">T</td><td align="center">T</td><td align="center">T</td></tr><tr><td align="center">T</td><td align="center">F</td><td align="center">F</td></tr><tr><td align="center">F</td><td align="center">T</td><td align="center">T</td></tr><tr><td align="center">F</td><td align="center">F</td><td align="center">T</td></tr></tbody></table><blockquote><p>条件语句只规定了，当p为真时，q必须为真，否者整个命题就会时一个假命题；但是条件命题并没有规定，p为假时，q必须为什么状态。所以当p为假时，无论q为何值，真个命题都是一个真命题。</p></blockquote><p>条件语句还有三种衍生的命题：<br>1.逆命题：q→p称为p→q的逆命题<br>2.逆否命题：┑q→┑p称为p→q的逆否命题，与p→q由着相同的真值。<br>一个条件语句总是与它的逆否命题是等价的<br>3.反命题：┑p→┑q称为p→q的逆命题</p><ul><li>双条件语句：表示只有当p、q具有相同的真值是才为真。记作：p↔q<blockquote><p>生活中常将这种逻辑翻译为p当且仅当q</p></blockquote></li></ul><table><thead><tr><th align="center">p</th><th align="center">q</th><th align="center">p↔q</th></tr></thead><tbody><tr><td align="center">T</td><td align="center">T</td><td align="center">T</td></tr><tr><td align="center">T</td><td align="center">F</td><td align="center">F</td></tr><tr><td align="center">F</td><td align="center">T</td><td align="center">F</td></tr><tr><td align="center">F</td><td align="center">F</td><td align="center">T</td></tr></tbody></table><h2 id="运算符的优先级"><a href="#运算符的优先级" class="headerlink" title="运算符的优先级"></a>运算符的优先级</h2><p>一个复合命题通常由几个命题通过逻辑运算符链接。为了更好的将一个复合命题转换为符号表示的命题，而不至于产生歧义，于是规定了逻辑符的优先级：</p><table><thead><tr><th align="center">运算符</th><th align="center">优先级</th></tr></thead><tbody><tr><td align="center">┑</td><td align="center">1</td></tr><tr><td align="center">∧</td><td align="center">2</td></tr><tr><td align="center">∨</td><td align="center">3</td></tr><tr><td align="center">→</td><td align="center">4</td></tr><tr><td align="center">↔</td><td align="center">5</td></tr></tbody></table><p>例如：p→q∨r就相当于p→(q∨r)</p><h2 id="比特运算"><a href="#比特运算" class="headerlink" title="比特运算"></a>比特运算</h2><p>比特运算即计算机中的位运算。一个比特相当一个二进制位，1代表真，0代表假。这种只能表示真和假两种状态的取值情况，在计算机中由称为布尔量。一个十进制的数可以转换为一连串的二进制位，称位比特串。将两个比特串之间进行逻辑运算（通常只支持合取、析取和异或的计算）称为比特运算。例如：<br>01 1011 0110<br>11 0001 1101<br>——————<br>11 1011 1111  按位OR<br>01 0001 0100  按位AND<br>10 1010 1011  按位XOR</p><p><a href="https://mubu.com/doc/2LqraMt3Mw" target="_blank" rel="noopener">思维导图版笔记点击此处</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章主要总结了来自《离散数学及其应用》的第一章第一小结的内容。主要包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;命题的一些基本概念&lt;/li&gt;
&lt;li&gt;逻辑运算符及其运算规则&lt;/li&gt;
&lt;li&gt;比特运算&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="离散数学" scheme="https://quandongli.github.io/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="离散数学" scheme="https://quandongli.github.io/tags/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
      <category term="命题的逻辑" scheme="https://quandongli.github.io/tags/%E5%91%BD%E9%A2%98%E7%9A%84%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之大数</title>
    <link href="https://quandongli.github.io/post/102131cd.html"/>
    <id>https://quandongli.github.io/post/102131cd.html</id>
    <published>2020-01-15T05:28:59.000Z</published>
    <updated>2020-01-15T05:30:31.232Z</updated>
    
    <content type="html"><![CDATA[<p>前面总结Java中的基本数据类型，一共有四类八种。但是在前面的总结中，对于数值来说都是由界限的，一旦超出了该类型能表达的最大数值就会报错。其对于浮点数来说，无论是单精度的float类型还是双精度的double类型其能表示的精度也是存在界限的。但是在在日常生活中，我们能使用的数值是无限的，那么在java中如何创造一个可以长度无限的数值呢？java中为我们提供了大数。</p><a id="more"></a><h2 id="声明一个大数"><a href="#声明一个大数" class="headerlink" title="声明一个大数"></a>声明一个大数</h2><p>首先在使用大数时，需要提前导入java.math包，在该包中提供了两个类：BigInteger(可以实现任意精度的整数运算)、BigDecimal(可以实现那任意精度的浮点运算)。<br>声明一个大数由两个方法：</p><ul><li>方法一：将一个普通类型的数字转换成大数：valueOf(num),这样定义的大数，如果num直接时一个数字，则不能超过int类型的范围，如果num时一个给定的数值的long类型，那么其最大数值也不能超过long类型的最大数值，也就是说，<strong>这种方法不能定义一个任意长度的大数</strong>。</li><li>方法二：使用一个带字符串参数的构造器。如：BigInteger a = new BigInteger(“2124564231544248545”)。这种方法可以为变量初始化一个任意大小的数值。</li></ul><p>java中也定义了一些大数常量，例如整型大数有：</p><ul><li>0：BigInteger.ZERO</li><li>1：BigInteger.ONE</li><li>2：BigInteger.TWO</li><li>10：BigInteger.TEN</li></ul><blockquote><p>定义一个浮点型的大数的方法也类似，不过使用的是BigDecimal</p></blockquote><h2 id="大数的计算"><a href="#大数的计算" class="headerlink" title="大数的计算"></a>大数的计算</h2><p>大数的计算不能向普通类型那样通过算术运算符进行计算，而必须通过math提供的方法进行相应计算。例如：如果要将大数a和b相加，不能直接写成a+b，而是应该调用add方法：a.add​(b)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BigInteger a = BigInteger.valueOf(<span class="number">10</span>);</span><br><span class="line">BigInteger b = <span class="keyword">new</span> BigInteger(<span class="string">"5451154231844784217515484"</span>);</span><br><span class="line">BigInteger c;</span><br><span class="line">c = a.add(b);</span><br><span class="line">System.out.println(c);<span class="comment">//5451154231844784217515494</span></span><br></pre></td></tr></table></figure><p>比较常用的方法有:</p><ul><li>相加:add​(BigInteger val)</li><li>相减:subtract​(BigInteger val)</li><li>相乘:multiply​(BigInteger val)</li><li>取余：divide​(BigInteger val)</li><li>取模：mod​(BigInteger m)</li><li>平方根：sqrt()</li><li>判断是否相等：compareTo​(BigInteger val)<blockquote><p>浮点型大数的运算方法也类似。  </p></blockquote></li></ul><p>更多的方法可以通过访问在线API文档进行了解：<a href="http://www.apiref.com/java11-zh/java.base/java/math/BigDecimal.html" target="_blank" rel="noopener">http://www.apiref.com/java11-zh/java.base/java/math/BigDecimal.html</a></p><p><a href="https://mubu.com/doc/1uRAfMWHaA" target="_blank" rel="noopener">幕布思维导图版笔记点击</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前面总结Java中的基本数据类型，一共有四类八种。但是在前面的总结中，对于数值来说都是由界限的，一旦超出了该类型能表达的最大数值就会报错。其对于浮点数来说，无论是单精度的float类型还是双精度的double类型其能表示的精度也是存在界限的。但是在在日常生活中，我们能使用的数值是无限的，那么在java中如何创造一个可以长度无限的数值呢？java中为我们提供了大数。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://quandongli.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://quandongli.github.io/tags/java/"/>
    
      <category term="大数" scheme="https://quandongli.github.io/tags/%E5%A4%A7%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之流程控制</title>
    <link href="https://quandongli.github.io/post/1d298e9e.html"/>
    <id>https://quandongli.github.io/post/1d298e9e.html</id>
    <published>2020-01-14T05:46:52.000Z</published>
    <updated>2020-01-14T06:17:30.763Z</updated>
    
    <content type="html"><![CDATA[<p>本文将对Java中用于控制流程的相关语法进行总结，内容包括：</p><ul><li>判断语句</li><li>选择语句</li><li>循环语句</li><li>break和continue的使用<a id="more"></a>跟其他语言一样，在Java语言中也同样存在者流程控制的语句，他们的主要做用时控制程序语句的运行顺序。在Java语言中流程控制语句可以分为判断语句、选择语句以及循环语句。<!-- more --><h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2>判断语句的共同特征时，只有在满足条件的情况下才会进行，且只会运行一次。<h3 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h3>if语句主要由关系表达式以及语句体构成，其形式如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">    语句体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其执行流程是：当需要执行if语句时，先会判断if里面的关系表达式是否为true，如果为true将会执行if语句的语句体，如果为false，则会直接跳过。<img src="/quandongli.github.io/post/1d298e9e/if.png" class title="if语句流程图"><h3 id="if-…else语句"><a href="#if-…else语句" class="headerlink" title="if …else语句"></a>if …else语句</h3>if…else语句用于需要进行”二者选其一”的情况，其形式是：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(关系表达式)&#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其执行流程是：如果关系表达式为true时，就会执行语句体1，如果关系表达式为false，则会执行语句体2。<img src="/quandongli.github.io/post/1d298e9e/ifelse.png" class title="ifelse语句流程图"><h3 id="if-…else-if…-else语句"><a href="#if-…else-if…-else语句" class="headerlink" title="if …else if….else语句"></a>if …else if….else语句</h3>if …else if….else语句用于需要进行多次判断的情况，其功能类似与switch语句，但是比switch语句更为适用。其形式如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(判断条件<span class="number">1</span>)&#123;</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(判断条件<span class="number">2</span>)&#123;</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(判断条件n)&#123;</span><br><span class="line">    语句体n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">    语句体n+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>其执行流程时，当判断条件1为true时则执行语句体1，如果判断条件1为false，则会继续往下执行else if语句，那个首先为true则会执行相应的语句体。如果所有的判断条件都为false，则会执行else语句。<img src="/quandongli.github.io/post/1d298e9e/elseif2.png" class title="elseif语句流程图"></li></ul><h2 id="选择结构"><a href="#选择结构" class="headerlink" title="选择结构"></a>选择结构</h2><p>选择结构的作用类似于判断语句，但是其执行情况会比判断语句更加明确。选择结构主要用于选择有限的情况，类似于做选择题，程序将会几个选项中选择一个执行。<br>选择结构使用的时switch结构。其形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">1</span>:</span><br><span class="line">    语句体<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 常量值<span class="number">2</span>:</span><br><span class="line">    语句体<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        语句体n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其执行流程是：switch中的表达式将会计算处一个值，然后将会找到与这个值相等的case，并执行相应的语句体，否则将会执行default中的语句体。<br>使用switch语句需要注意以下几个方面</p><ul><li>多个case的常量值不能重复</li><li>其常量值只能是：byte/short/char/int/String/enum类型</li><li>除最后一个break可以省略外，其他break不可以省略。</li></ul><p>其执行流程如下：</p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>以上的结构，程序将会至下而上依次执行，不会返回，执行第二遍。对于循环结构而言，程序将可以，重复执行n遍。<br>一个循环结构主要由以下几个部分构成：</p><ul><li>初始化语句：在循环最开始执行，且只执行一次</li><li>条件判断：只有成立，才继续执行</li><li>循环体：执行的内容</li><li>步进语句：每次循环之后都要进行的一些扫尾工作（比如变量的迭代等）</li></ul><h3 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h3><p>for循环语句的结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化表达式;布尔表达式;步进表达式)</span><br><span class="line">&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中初始化表达式的作用是，将相关的变量设定一个初始状态，布尔表达式用来判断循环何时结束，步进表达式的作用是使相关变量不断向结束状态靠近。三者中初始化表达式可以放在for语句开始之前，不步进表达式可以放在for的循环体中。但是一般般不可以省略，如果设置不当将会造成无限循环。<br>for循环开始时会执行一次初始化表达式，这个表达式在之后的循环中将不会再执行。接着会执行布尔表达式，如果结果为true将会执行循环体语句，如果结果为false，则会结束循环，执行一次循环体语句之后，将会执行一次步进表达式。再执行布尔表达式、循环体。如此循环，直到布尔表达式结果为false。</p><img src="/quandongli.github.io/post/1d298e9e/for2.png" class title="for语句流程图"><h3 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h3><p>while语句的形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化表达式;</span><br><span class="line"><span class="keyword">while</span>(布尔表达式)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">    步进表达式;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>while语句再执行之间都会进行一次布尔表达式的判断，只有在布尔表达式为false的情况下才会结束循环，否则将会执行循环内容。其流程图如下：</p><img src="/quandongli.github.io/post/1d298e9e/while2.png" class title="while语句流程图"><h3 id="do-while语句"><a href="#do-while语句" class="headerlink" title="do while语句"></a>do while语句</h3><p>do while语句的的形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">初始化表达式;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体;</span><br><span class="line">    步进表达式;</span><br><span class="line">&#125;<span class="keyword">while</span>(布尔表达式)</span><br></pre></td></tr></table></figure><p>do while语句与while语句的不同之处在与，无论初始条件为什么，do while语句都将会执行一次，在执行完第一次后，将会通过布尔表达式判断是否继续执行。其流程图如下：</p><img src="/quandongli.github.io/post/1d298e9e/dowhile2.png" class title="dowhile语句流程图"><h2 id="中断流程控制语句"><a href="#中断流程控制语句" class="headerlink" title="中断流程控制语句"></a>中断流程控制语句</h2><p>在java中存在着两个可以改变流程执行情况的语句，分别时break与continue。<br>break的作用时结束正在执行的流程，比如直接跳出循环等。而continue的作用越过后面还没有执行的部分，直接跳转到循环的首部，进行下一次的循环，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将会打印12345678910</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.printf(<span class="string">"%d"</span>,j++);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只会输出12</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">System.out.printf(<span class="string">"%d"</span>,i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不会输出3</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">System.out.printf(<span class="string">"%d"</span>,i);<span class="comment">//输出1245678910</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外java中的break和continue还支持标签功能，可以指定跳到哪里，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在j=3时，将只会跳出j的那层循环，程序的结果为：</span></span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="number">1</span> <span class="number">2</span> </span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">System.out.printf(<span class="string">"%d "</span>,j);</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//加了标签后当j=3时将会跳出最外面的循环，程序将只会输出1 2</span></span><br><span class="line">there:</span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;=<span class="number">3</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=<span class="number">3</span>;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j == <span class="number">3</span>)</span><br><span class="line"><span class="keyword">break</span> there;</span><br><span class="line">System.out.printf(<span class="string">"%d "</span>,j);</span><br><span class="line">&#125;</span><br><span class="line">System.out.printf(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://mubu.com/doc/2uGN7TcxUw" target="_blank" rel="noopener">幕布版思维导图点击此处</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将对Java中用于控制流程的相关语法进行总结，内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断语句&lt;/li&gt;
&lt;li&gt;选择语句&lt;/li&gt;
&lt;li&gt;循环语句&lt;/li&gt;
&lt;li&gt;break和continue的使用&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://quandongli.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://quandongli.github.io/tags/java/"/>
    
      <category term="流程控制" scheme="https://quandongli.github.io/tags/%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之字符串</title>
    <link href="https://quandongli.github.io/post/eea9faf9.html"/>
    <id>https://quandongli.github.io/post/eea9faf9.html</id>
    <published>2020-01-11T12:26:46.000Z</published>
    <updated>2020-01-12T02:12:59.232Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章将会对Java中字符串的相关操作进行总结</p><a id="more"></a><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>Java中字符串是用双引号引起来的一串字符或unicode序列，例如：”hello”就是一个在字符串，Java中使用string类对字符串进行定义，例如：String str = “hello”即定义了一个在字符串str，且str的值是hello。</p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><h3 id="取子串"><a href="#取子串" class="headerlink" title="取子串"></a>取子串</h3><p>substring(a,b)方法将字符串a位置开始起到b位置（不包含b位置）上的字符取出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello"</span>.substring(<span class="number">0</span>,<span class="number">3</span>));<span class="comment">//将会返回Hel</span></span><br></pre></td></tr></table></figure><h3 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h3><p>将两个甚至多个字符串拼接成一个字符串有一下三个方法：</p><ul><li><p>a+b：将a和b两个字符串合并为一个字符串；当a、b中只有一个为字符串时，不为字符串的值也会转换为字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello"</span>+ <span class="number">10</span>);<span class="comment">//将会输出Hello10​</span></span><br></pre></td></tr></table></figure></li><li><p>join(a,b)：将多个字符串进行拼接，并且以a在字符串作为分割；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(String.join(<span class="string">"! "</span>,<span class="string">"Hello"</span>,<span class="string">"World"</span>));<span class="comment">//将会输出Hello！world​</span></span><br></pre></td></tr></table></figure></li><li><p>repeat(n):将字符串重复n遍</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ystem.out.println(<span class="string">"Hello"</span>.repeat(<span class="number">2</span>));<span class="comment">//将会输出HelloHello​</span></span><br></pre></td></tr></table></figure><h3 id="修改字符串"><a href="#修改字符串" class="headerlink" title="修改字符串"></a>修改字符串</h3><p>在java中字符串实际上是不可变的，可以这样理解：虽然果篮里面可以放各种水果，但是苹果始终都是苹果，不会变成香蕉。这其实是java中的工作机制造成的。这将在文章中最后进行介绍。<br>既然Java中不允许对字符串的元素进行修改，那么我们从现有的字符串中选取出我们想要的在字符，然后再与其他的字符拼接字组成我们想要的字符串。<br>我们可以先用substring方法取处原字符串中需要保留的字符串，然后通过+将替换的字符串进行拼接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello"</span>.substring(<span class="number">0</span>,<span class="number">3</span>) + <span class="string">"p!"</span>);<span class="comment">//将会返回Help!​</span></span><br></pre></td></tr></table></figure><h3 id="判断字符串是否相等"><a href="#判断字符串是否相等" class="headerlink" title="判断字符串是否相等"></a>判断字符串是否相等</h3><p>在java中判断字符串是否不可以用==判断两个字符是否相等，这判断的时两个字符串是否存储同一位置。<br>在Java中判段两个字符串是否相等可以使用以下两种方法：</p></li><li><p>s.equals(t):如果字符串s与t相等将会返回true，否则将会返回false（区分大小写）</p></li><li><p>s.equalsIgnoreCase(t):判断两个字符串是否相等，不区分大小写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"Hello"</span>.equals(<span class="string">"hello"</span>));<span class="comment">//返回false​System.out.println("Hello".equalsIgnoreCase("hello"));//返回true</span></span><br></pre></td></tr></table></figure><h3 id="判断字符串是否为空"><a href="#判断字符串是否为空" class="headerlink" title="判断字符串是否为空"></a>判断字符串是否为空</h3><p>在Java中定义一个空字符串有两种方式，对应了两种不同的判断空串的方法，他们之间的判断方法不可以错用。</p></li><li><p>“”：这种定义空串的方式，在计算机的“眼里”，他是有内容的（内容为空），有长度的(长度为0)，所以这种空串有以下两种方式进行判断：</p><ul><li>if(str.length() == 0)//判断长度是否为0</li><li>if(str.equals(“”))//判断内容是否为空</li></ul></li><li><p>null：这种定义空串的方式，相当于告诉计算机，我要一个字符串，但是里面没有任何内容。这种方式定义的字符串可以使用：if(str == null)进行判断。</p><h3 id="字符串的长度"><a href="#字符串的长度" class="headerlink" title="字符串的长度"></a>字符串的长度</h3><p>由于java的char类型是一个采用UTF-16编码表示的unicode码点的代码单元。前面也说过虽然这种方式能够容纳更多的字符，但是随之类似与中文这样表意的字符的加入，这种编码方式依然被挤爆了。所以java中有些字符占了两个代码单元。<br>于是，很自然的，Java中有以下两种方式求字符串分别来求两种不同角度的字符串长度。</p></li><li><p>length：返回字符串所需要的代码单元数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"world"</span>.length());<span class="comment">//将会返回5​</span></span><br></pre></td></tr></table></figure></li><li><p>codePointCount(0,str.length()):返回实际的长度，即码点数量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"world⊕"</span>.codePointCount(<span class="number">0</span>,<span class="string">"world⊕"</span>.length()));<span class="comment">//返回7，⊕字符需要使用两个代码单元​</span></span><br></pre></td></tr></table></figure><h3 id="随机访问"><a href="#随机访问" class="headerlink" title="随机访问"></a>随机访问</h3><p>charAt(n)：返回位置n的代码单元</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"world"</span>.charAt(<span class="number">0</span>));<span class="comment">//将返回w</span></span><br></pre></td></tr></table></figure><h3 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h3><p>这里记录Java中三种方式对字符串进行遍历（当不止这三种方式）<br>方法一：charAt方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; str.length();i++) &#123;</span><br><span class="line"></span><br><span class="line"> System.out.println(str.charAt(i)); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法二：substring方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; str.length();i++) &#123;</span><br><span class="line"></span><br><span class="line"> System.out.println(str.substring(i,i+<span class="number">1</span>)); </span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法三：toCharArray方法，将字符串方法转换成字符数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[]  c = str.toCharArray();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; c.length;i++) &#123;</span><br><span class="line"></span><br><span class="line">System.out.println(c[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>最后java中的string类有数千个方法，这里不可能逐个解释，也不需要对每一个都了如&gt;指掌，有需要的时候可以访问java的额API文档进行了解: <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">https://docs.oracle.com/javase/8/docs/api/</a></p></blockquote><h2 id="浅谈Java不可变类"><a href="#浅谈Java不可变类" class="headerlink" title="浅谈Java不可变类"></a>浅谈Java不可变类</h2><p>在java中有很多的不可变类，例如Interger、Long、String。<br>Java将不可变类放到了一个公共的存储池中。我们定义一个字符串str，然后将它初始化为“hello”，实际上其过程可以理解为，计算机划分了一块空间，然后将str1指向它。这块空间里面的东西将无法改变,但是str在字符串确可以指向其他的在字符串</p><img src="/quandongli.github.io/post/eea9faf9/%E4%B8%8D%E5%8F%AF%E5%8F%981.png" class title="不可变1"><p>现在在定义一个字符串str2，其值也初始化为hello，进行==判断将会判断为true</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      String str1 = <span class="string">"hello"</span>;</span><br><span class="line">String str2 = <span class="string">"hello"</span>;</span><br><span class="line">System.out.println(str1 == str2);<span class="comment">//显示为true</span></span><br></pre></td></tr></table></figure><p>这是因为str2也指向了这个hello在字符串所在的空间</p><img src="/quandongli.github.io/post/eea9faf9/%E4%B8%8D%E5%8F%AF%E5%8F%982.png" class title="不可变2"><p>但是如果现在定义一个在字符串str3，虽然str3也初始化为hello，但是初始化的方式是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="string">"hel"</span>;</span><br><span class="line">String str3 = str2+<span class="string">"lo"</span>;</span><br></pre></td></tr></table></figure><p>现在分别进行==判断和用equals方法进行判断将会得到不同的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String str2 = <span class="string">"hel"</span>;</span><br><span class="line">String str3 = str2+<span class="string">"lo"</span>;</span><br><span class="line">System.out.println(str1 == str3);<span class="comment">//false</span></span><br><span class="line">System.out.println(str1.equals(str3));<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>这是因为Java实际上只是共享了字符串的字面量（即hello这个值），但是对于+和substring等方法的得到的字符串却不会进行共享。</p><img src="/quandongli.github.io/post/eea9faf9/%E4%B8%8D%E5%8F%AF%E5%8F%983.png" class title="不可变3"><p>设计不可变类型的最大的好处就是当需要进行复制一个字符串变量是，只需要将这个变量指向共享的空间就可以了。但是也为诸如提取字串、拼接等带来了麻烦。但是java设计者认为共享空间带来的好处更大。<br><a href https: mubu.com doc 3oiq0h5l8w"">查看幕布版笔记请点击</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章将会对Java中字符串的相关操作进行总结&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://quandongli.github.io/categories/java/"/>
    
      <category term="字符串" scheme="https://quandongli.github.io/categories/java/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    
      <category term="-java -字符串" scheme="https://quandongli.github.io/tags/java-%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之运算符</title>
    <link href="https://quandongli.github.io/post/e0ba64a3.html"/>
    <id>https://quandongli.github.io/post/e0ba64a3.html</id>
    <published>2020-01-11T05:05:15.000Z</published>
    <updated>2020-01-13T06:48:48.441Z</updated>
    
    <content type="html"><![CDATA[<p>本篇文章将会对Java语言中的计算规则进行总结，内容包括：</p><ul><li>基本运算符</li><li>Java中使用数学函数</li><li>类型转换</li><li>赋值操作</li><li>关系运算</li><li>位运算</li><li>运算优先级<a id="more"></a></li></ul><h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><p>&emsp;&emsp;在Java中加、减、乘的运算符号分别是+ 、- 、 *，其运算结果与实际生活中数学计算的结果一致，但是对于除法计算，在计算机中存在较大的差异。<br>&emsp;&emsp;在java中不存在除法运算符，只存在取模运算（/）和取余运算（%），取模运算就是取整运算，取余运算将会得到余数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">5</span>/<span class="number">2</span>);<span class="comment">//将会输出2</span></span><br><span class="line">System.out.println(<span class="number">5</span>%<span class="number">2</span>);<span class="comment">//将会输出1</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;在java中“=”，是赋值的意思（将右边的值赋给左边的变量），而非判断两个数值是否相等（在java中判断是否相等用“==”）。<br>&emsp;&emsp;在Java中也存在着一些“简写”形式的表达式子。比如：如果表达式为x = x+4;可以写成x+=4.（同样的有+=、-=、=、%=等）；表达是i++(或i–)表示i自增（自减）1，需要注意的是，这种写法表示的是先使用i的值，使用完之后i再自增（自减）1，而++i（–i）表示的是先将i的是进行自增（自减）1，再使用i的值。</p><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><p>&emsp;&emsp;对于需要进行的诸如幂运算、开方、取对数等数学运算，Java中Math类来提供了各种各样的额数学运算，例如：求平方根的sqrt(),幂运算的pow等。使用math类可以通过两种方式，一种是直接使用，如：Math.sqrt(),也可以在程序中引入math类，再程序的开始处加上“import static java.lang.Math.*;”即可，之后再使用sqrt函数直接写即可。<br>&emsp;&emsp;再math类中还提供了一种“特殊”的取模运算。再java程序中如果直接使用/进行取模，如果计算的被除数是一个负数，那么得到的结果也将会是一个负数。比如-5/2将会得到的是-2而不是日常数学计算中的2，math类中提供了floorMod方法可以将这种情况下的计算结果取正，但是对于除数是负数的情况，也将无能为力。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>&emsp;&emsp;在java中有两种情况将会发生类型转换。<br>&emsp;&emsp;一种是当二元运算符（如+）连接的两个数值中类型不同时，则计算结果的类型将会转换为两者中精度更高的类型，比如float%int类型，其计算结果将会是float类型。<br>&emsp;&emsp;另外一种情况就是进行强制类型转换时，例如int i = (int)n;那么无论n的数值是一个什么类型都会被转换为int类型。<br>&emsp;&emsp;java中将浮点数转换为整数时，该方式将直接将小数部分截断，例如2.6转换为int类型的结果是2。math类中的round方法进行类型转换时将取一个最接近的数。如9.8将会转换为10但是9.1将会转换为9。<br>&emsp;&emsp;在进行类型转换的过程有些类型之间的转换将会产生信息损失，有些则不会。下图展现的就是在二元运算符中发生类型转换时的情形。</p><img src="/quandongli.github.io/post/e0ba64a3/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2.png" class title="类型转换"><p>&emsp;&emsp;最后一种发生的比较隐蔽。对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，javac编译器将会自动的为我们加上(byte)(short))(char),这也是为什么我们在对char类型整形值时有时不会报错的原因，比如：char c = 65;进行打印输出时会打印处A。但是对于如下的一段代码将会进行报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span>  a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">short</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">short</span> result = <span class="number">10</span>+<span class="number">20</span>;<span class="comment">//等于30 </span></span><br><span class="line"><span class="keyword">short</span> result1 c = a + c;<span class="comment">//将会报错：cannot convert from int to short</span></span><br></pre></td></tr></table></figure><p>&emsp;&emsp;发生这种现象的原因时有与java中编译器的常量优化造成的。在Java中，在给变量赋值时，如果等号右侧的表达式中全部都是常量，没有任何变量时，编译器将javac将会直接计算出结果，而不是等到运行程序时再进行计算。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> result = <span class="number">10</span>+<span class="number">20</span>;<span class="comment">//编译器将会直接将result的值设定为30，而不是等运行的时候再进行计算</span></span><br></pre></td></tr></table></figure><p>但是如果在等号的有变量存在，则不会进行这种优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> result = a + <span class="number">20</span><span class="comment">//结果将会报错，因为a时一个short类型的变量，20默认时int型，则结过因该时一个整型。但是这里的resul时一个short类型，所以会报错</span></span><br></pre></td></tr></table></figure><p>这时候就需要进行程序员进行以下强制转换:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">short</span> result = (<span class="keyword">short</span>)(a + <span class="number">20</span>);<span class="comment">//结果会被强制转换为short类型，不会报错</span></span><br></pre></td></tr></table></figure><blockquote><p>Java这么做的原因时，java的设计者认为，类似于10+20这样的计算，它的结果时确定的，不会变的，所以不如在编译的之后就直接算出来，这样就不要再在程序运行的时候取浪费计算机的资源进行计算了，但是如果有变量存在，例如：a + 20，它的结果是由a的值决定的，但是a时一个变量，其值是可能发生变化的，所以在编译的时候不能进行计算，必须等到运行的时候才能进行计算。</p></blockquote><h2 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h2><p>&emsp;&emsp;java中存在以下几种位运算：</p><ol><li>==或!=（&gt; 、&lt;、&gt;=、&lt;=也类似）：判断两个值是都相等或不相等，是则返回true，否则返回false</li><li>与：A&amp;&amp;B：两者中有一个为false则表达式为false；<strong>如果A已经判断为false则B将不会进行计算</strong></li><li>或：A||B：两者中有一个为true则表达式结果为true；<strong>如果A已经判断为true则B将不会进行计算</strong></li><li>非！：取反，false变true，true变false</li><li>三目运算符：condition?expression1:expression2：如果condition为真则用expression1，否者用expression2<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2>&emsp;&emsp;java中存在以下几种位运算：</li><li>非 ~：将二进制的1变为0，0变为1</li><li>按位或|：两个操作数其中一个是1时就是1</li><li>按位与&amp;：两个操作数都是1时才是1</li><li>异或：java中没有同或从高位开始比较，如果相同则为0，不相同则为1。(java中没有同或)</li><li>右移 A&lt; &lt; X：将操作数A按二进制向右移x位</li><li>左移：A&gt;&gt;X：将操作数A按二进制向左移x位</li><li>无符号右移：A&gt;&gt;&gt;x：将操作数A按二进制向右移x位，并用零填充最高位。<br>示例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> j,k,p,q,s,d,f;</span><br><span class="line">j = <span class="number">10</span> | <span class="number">0b1100</span>;</span><br><span class="line">k = <span class="number">10</span> &amp; <span class="number">0b1100</span>;</span><br><span class="line">p = ~<span class="number">10</span>;</span><br><span class="line">q = <span class="number">10</span> &lt;&lt; <span class="number">3</span>;</span><br><span class="line">s = <span class="number">10</span> &gt;&gt; <span class="number">3</span>;</span><br><span class="line">d = -<span class="number">10</span>&gt;&gt;&gt;<span class="number">1</span>;</span><br><span class="line">System.out.println(<span class="string">"i = "</span> + Integer.toBinaryString(i));<span class="comment">//1010</span></span><br><span class="line">System.out.println(<span class="string">"j = "</span> +Integer.toBinaryString(j));<span class="comment">//1110</span></span><br><span class="line">System.out.println(<span class="string">"k = "</span> +Integer.toBinaryString(k));<span class="comment">//1000</span></span><br><span class="line">System.out.println(<span class="string">"p = "</span> +Integer.toBinaryString(p));<span class="comment">//11111111111111111111111111110101</span></span><br><span class="line">System.out.println(<span class="string">"q = "</span> +Integer.toBinaryString(q));<span class="comment">//1010000</span></span><br><span class="line">System.out.println(<span class="string">"s = "</span> +Integer.toBinaryString(s));<span class="comment">//1</span></span><br><span class="line">System.out.println(<span class="string">"d = "</span> +Integer.toBinaryString(d));<span class="comment">//1111111111111111111111111111011</span></span><br></pre></td></tr></table></figure><h2 id="运算的优先级"><a href="#运算的优先级" class="headerlink" title="运算的优先级"></a>运算的优先级</h2>如果使用圆括号，则按照运算符的优先级进行运算。同一级别的运算符将会按照从左到右的次序进行计算（一些右结合的运算符除外），例如a&amp;&amp;b||c就相当于(a&amp;&amp;b)||c,具体运算符优先级见下图：<img src="/quandongli.github.io/post/e0ba64a3/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.png" class title="运算符优先级"></li></ol><p><a href="https://mubu.com/doc/17UMhlGHaA" target="_blank" rel="noopener" title="思维导图链接">查看幕布思维导图版请点此处</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本篇文章将会对Java语言中的计算规则进行总结，内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;基本运算符&lt;/li&gt;
&lt;li&gt;Java中使用数学函数&lt;/li&gt;
&lt;li&gt;类型转换&lt;/li&gt;
&lt;li&gt;赋值操作&lt;/li&gt;
&lt;li&gt;关系运算&lt;/li&gt;
&lt;li&gt;位运算&lt;/li&gt;
&lt;li&gt;运算优先级&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://quandongli.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://quandongli.github.io/tags/java/"/>
    
      <category term="运算符" scheme="https://quandongli.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    
  </entry>
  
  <entry>
    <title>Java编程基础之变量与常量</title>
    <link href="https://quandongli.github.io/post/1b17473c.html"/>
    <id>https://quandongli.github.io/post/1b17473c.html</id>
    <published>2020-01-10T03:18:32.000Z</published>
    <updated>2020-01-11T05:19:29.588Z</updated>
    
    <content type="html"><![CDATA[<p>再编程语言中变量与常量是两个非常重要且基础的两个概念，变量的声明是编程中一个基本操作。</p><a id="more"></a><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>&emsp;&emsp;变量是指再程序运行的过程中存储可以变化的数据，声明一个变量，将向系统申请一块内存（大小由变量的类型决定）,常量是指再程序运行期间不变的数据。<br>&emsp;&emsp;变量就好比是一个水果篮，里面可以放苹果、香蕉等各种水果，里面放的东西是可以变的，但是苹果始终是苹果，不会变成香蕉。</p><h2 id="声明变量"><a href="#声明变量" class="headerlink" title="声明变量"></a>声明变量</h2><p>&emsp;&emsp;变量再使用前都需要进行声明，在java中声明变量的格式为：类型名 变量名;，比如double salary；这里就声明了一个double类型的名为salary变量。<br>&emsp;&emsp;变量的命名需要遵循以下几点规则：</p><ol><li>变量名必须是以字母开关并以字母或数字构成的序列。<blockquote><p>这里的字母包括Unicode编码所包含的所有表示字母的字符，如：_、$<br>要想知道某个字符是不是unicode中定义的字母可以使用Charcter类中的isJavaIdentifierStart和isJavaIdentifierPart方法进行判断​​</p></blockquote></li><li>不能使用java中的保留字作为变量名，如；int，double等</li><li>Java中变量名是区分大小写的</li><li>变量名没有长度限制<h2 id="变量的初始化"><a href="#变量的初始化" class="headerlink" title="变量的初始化"></a>变量的初始化</h2>&emsp;&emsp;在声明变量名之后，应该使用赋值语句对该变量进行初始化，使用未初始化的变量的值将会导致程序错误。比如以下操作，编译器会进行报错。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">System.out.println(num);<span class="comment">//num变量里面什么内容都没有，无法打印</span></span><br></pre></td></tr></table></figure>但是如果进行如下操作将回正常输出：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">11</span>;</span><br><span class="line">System.out.println(num);<span class="comment">//将会输出11</span></span><br></pre></td></tr></table></figure><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2>在java中常量的声明方式是final 类型名 变量名;比如final int NUM = 11;<blockquote><p>与c语言中定义常量不同的是，c语言中常量的使用的是#define，且不需要指定常量的类型，用等号进行赋值，没有分号<br>在Java中使用final声明的常量，需要注意以下几点：</p></blockquote></li><li>final变量不能再次赋值；</li><li>final方法不能被重写；</li><li>final类不能被继承；</li><li>如果常量定义再main方法的内部，则该类的其他方法也能够使用这个常量</li><li>如果这个常量被public修饰，则这个常量也可以被其他类使用</li></ol><h2 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型"></a>枚举类型</h2><p>在编程实践时，有时候一个变量只会在几个值之间取值，比如描述日常生活中衣服的尺码时，一般就只有S、M、L、X等，这时候就可以使用枚举类型来表示衣服的尺寸。定义格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> Size &#123;SMALL,MEDIUM,LARGE&#125;;</span><br></pre></td></tr></table></figure><p>使用这个枚举类型，格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Size s = Size.MEDIUM;</span><br></pre></td></tr></table></figure><p><a href="https://mubu.com/doc/3qZ-EKYdHw" target="_blank" rel="noopener" title="思维导图链接">查看幕布思维导图版请点此处</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;再编程语言中变量与常量是两个非常重要且基础的两个概念，变量的声明是编程中一个基本操作。&lt;/p&gt;
    
    </summary>
    
    
      <category term="java" scheme="https://quandongli.github.io/categories/java/"/>
    
    
      <category term="java" scheme="https://quandongli.github.io/tags/java/"/>
    
      <category term="变量与常量" scheme="https://quandongli.github.io/tags/%E5%8F%98%E9%87%8F%E4%B8%8E%E5%B8%B8%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>Java基础之四种基础类型</title>
    <link href="https://quandongli.github.io/post/2f86de21.html"/>
    <id>https://quandongli.github.io/post/2f86de21.html</id>
    <published>2020-01-09T12:19:52.000Z</published>
    <updated>2020-01-17T05:20:19.344Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java数据类型概述"><a href="#java数据类型概述" class="headerlink" title="java数据类型概述"></a>java数据类型概述</h2><p>在java语言中有四类八种基本类型分别是：</p><a id="more"></a><ol><li>整型：long、int、short、byte</li><li>浮点型：double、float</li><li>char</li><li>boolean（布尔类型）</li></ol><h2 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h2><p>整型表示是没有小数部分的数值。在java中有定义了四种整型常量，他们表示范围从小到大分别是：</p><ul><li>长整型long：占8个字节</li><li>整型int：占4个字节</li><li>短整型short：占2个字节</li><li>byte：占1个字节</li></ul><table><thead><tr><th align="center">类型</th><th align="center">存储需求</th><th align="center">取值范围</th></tr></thead><tbody><tr><td align="center">long</td><td align="center">8字节</td><td align="center">-9223372036854775808 ~ 9223372036854775807</td></tr><tr><td align="center">short</td><td align="center">2字节</td><td align="center">-32768 ~ 32767</td></tr><tr><td align="center">byte</td><td align="center">1字节</td><td align="center">-128-127</td></tr></tbody></table><p>在java中整数类型与c语言中有几个不同点</p><ol><li>第一个不同点是，在Java语言中支持在为数值字面量加下划线，方便阅读，比如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">1000_000_000</span>);<span class="comment">//将输出为1000000000</span></span><br></pre></td></tr></table></figure></li><li>Java中每个类型所占的字节大小不会随着运行系统的变化而变化。这主要要是为了满足Java的设计目标：一处编译、处处运行。</li><li>第二个不同点，也是重要的不同点是，在Java语言中不支持无符号（unsigned）类型的整型，在Java中如果要表示一个无符号类型的数字将会是一个比较麻烦的事情（一般是通过升级类型，比如将byte类型升级为int类型，将int类型转换为long类型或者通过位运算）。</li></ol><p><strong>关于unsigned类型在以后遇到再进行详细讨论</strong></p><h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><p>所谓的浮点类型就是可以表示小数部分的数值，在Java中有两种浮点类型：<br>|类型|存储需求|取值范围|<br>|:-:|:-:|:-:|<br>|float|4字节|大约为+-3.40282347E+38F(有效位数为6~7位)|<br>|double|8字节|大约1.79769313486231570E+308（有效位数为15位）|<br>double表示的这种数值精度是float类型的两倍，所以一般称float类型为单精度浮点类型，double类型为双精度浮点类型。一般情况下小数默认为double类型。可以在小数数值后面加上一个f或者F将该数值表示为float类型。double类型可以在小数数值后面添加d或者D表示（也可以不加，直接默认）。</p><h2 id="char类型"><a href="#char类型" class="headerlink" title="char类型"></a>char类型</h2><p>&emsp;&emsp;char类型表示的是一个在字符，占两个字节，其的字面量值是用一个单引号引起来的一个字符，如’a’，但是不能用单引号引两个或以上的字符，如：’ab’,如果需要引两个或以上的字符这需要用一对双引号，这样表示的将会是字符串。<br>&emsp;&emsp;在Java中char类型是一个采用UTF-16编码表示Unicode码点的代码单元，这样做的原因是不同的编码方案下可能对应着不同的字母，且有些字母短一个字节就可以表示，但是有写字节表示比较长需要两个字节或多个字节，于是java设计者为了避免这样的事情发生（Java的设计思想是不管程序在哪运行，运行的结果都要一样），在初期效果确实达到了，但是随着中国等国家的表意文字的出现，这种设计也随之崩溃。于是乎，这种设计使得Java中的char类型并不是一个“称职”的类型，比如在字符串的一些操作中很容易产生错误，所以现在都<strong>强烈建议不要在java中使用char类型</strong></p><h2 id="boolean类型"><a href="#boolean类型" class="headerlink" title="boolean类型"></a>boolean类型</h2><p>Boolean（布尔）类型只有两个值：false以及true，用来判断逻辑条件。这里需要注意的是在java中<strong>整形和布尔值之间不能进行相互交换</strong>，在c语言中false可以用0来表示，true可以用1来表示，但是在Java中却不可以这样表示。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;java数据类型概述&quot;&gt;&lt;a href=&quot;#java数据类型概述&quot; class=&quot;headerlink&quot; title=&quot;java数据类型概述&quot;&gt;&lt;/a&gt;java数据类型概述&lt;/h2&gt;&lt;p&gt;在java语言中有四类八种基本类型分别是：&lt;/p&gt;
    
    </summary>
    
    
      <category term="Java" scheme="https://quandongli.github.io/categories/Java/"/>
    
    
      <category term="Java" scheme="https://quandongli.github.io/tags/Java/"/>
    
      <category term="基础类型" scheme="https://quandongli.github.io/tags/%E5%9F%BA%E7%A1%80%E7%B1%BB%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>web入门课程之基础知识</title>
    <link href="https://quandongli.github.io/post/a594f8b3.html"/>
    <id>https://quandongli.github.io/post/a594f8b3.html</id>
    <published>2020-01-03T04:22:51.000Z</published>
    <updated>2020-01-15T11:22:54.934Z</updated>
    
    <content type="html"><![CDATA[<h1 id="软件架构"><a href="#软件架构" class="headerlink" title="软件架构"></a>软件架构</h1><a id="more"></a><ol><li>C/S架构:Client/Server 客户端/服务器端<blockquote><p>在用户本地有一个客户端程序，在远程有一个服务器端程序<br>例如：QQ、迅雷。。。<br>缺点：</p><ol><li>开发、安装、部署、维护麻烦。<br>优点：</li><li>用户体验好</li></ol></blockquote></li><li>B/S：Browser/Server 浏览器/服务器端<blockquote><p>只需要一个浏览器，用户通过不同的网址（url），访问不同的服务器端程序<br>优点：</p><ol><li>开发、安装、部署、维护简单。<br>缺点：</li><li>如果应用过大，用户的体验可能会受到影响</li><li>对硬件要求过高</li></ol></blockquote><h1 id="B-S架构简介"><a href="#B-S架构简介" class="headerlink" title="B/S架构简介"></a>B/S架构简介</h1></li><li>资源分类<ol><li>静态资源<ul><li>使用静态网页技术开发发布的资源</li><li>特点：1. 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏览器。浏览器中内置了静态资源的解析引擎，可以展示静态资源</li><li>如：文本、图片、音频、视频、HTML、CSS、JavaScript</li></ul></li><li>动态资源<ul><li>使用动态网页及时发布的资源</li><li>特点：1. 所有用户访问，得到的结果可能不一样。</li><li><ol start="2"><li>如果用户请求的是动态资源，那么服务器就会执行动态资源，转换为静态资源，再发送给浏览器。</li></ol></li><li>如：jsp/servlet、php、sap…</li></ul></li></ol></li></ol><h1 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h1><ul><li>HTML：用于搭建基础页面，展示页面</li><li>CSS：用户美化页面，布局页面</li><li>JavaScript：控制页面的元素，让页面有一些动态效果。<br></li></ul><img src="/quandongli.github.io/post/a594f8b3/%E8%B5%84%E6%BA%90%E5%88%86%E7%B1%BB.jpg" class title="spaced title">]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;软件架构&quot;&gt;&lt;a href=&quot;#软件架构&quot; class=&quot;headerlink&quot; title=&quot;软件架构&quot;&gt;&lt;/a&gt;软件架构&lt;/h1&gt;
    
    </summary>
    
    
      <category term="前端" scheme="https://quandongli.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="web" scheme="https://quandongli.github.io/categories/%E5%89%8D%E7%AB%AF/web/"/>
    
    
      <category term="web" scheme="https://quandongli.github.io/tags/web/"/>
    
      <category term="html" scheme="https://quandongli.github.io/tags/html/"/>
    
  </entry>
  
</feed>
